# 小技术点总结
1. 闭包
之前感觉自己对闭包理解的很深刻，但是没记录原来的想法，后来就慢慢忘记了，这次好好记录一下。

定义：闭包就是在父函数中定义子函数，然后返回子函数，因为子函数在变量中保存，未被释放，所以父函数也不会被释放；因为作用域问题，子函数可以访问父函数的变量，但是父函数不能访问子函数的变量。再简单点就是：父函数返回子函数，并包裹自己的作用域给子函数调用。

使用：保存局部变量，或者说模拟静态变量。

注意问题：使用完注意销毁闭包，如果不销毁容易造成内存泄露。闭包的内存消耗很大，慎用。

2. 惰性计算

>惰性计算（Lazy evaluation），是指仅仅在真正需要执行的时候才计算表达式的值。充分利用其特性可以带来很多便利。

>避免不必要的计算，带来性能的提升。
对于Python中的条件表达式 if x and y,在x为false的情况下y表达式的值将不再计算。而对于if x or y，当x的值为true的时候将直接返回，不再计算y的值。因此编程中可以利用该特性，在 and逻辑中，将小概率发生的条件放在前面或者在or逻辑中，将大概率发生的时间放在前面，有助于性能的提升。

>节省空间，使得无线循环的数据结构成为可能。
Python中最经典的使用延迟计算的例子就是生成式表达器了，它尽在每次需要计算的时候才通过yield产生所需要的元素。
例：斐波那契数列在Python中实现起来很容易，使用yied对于while True也不会导致其他语言中所遇到的无线循环问题。
```python
       def fib():
           a,b=0,1
           while True:
               yield a
               a,b = b,a+b
       from itertools import islice
       print list(islice(fib(),5))
```
2.1 惰性求值，惰性计算，是俩个类似的技术。(我觉得其实是一样的，因为惰性求值还是惰性计算的结果)

惰性求值就是需要使用的时候再求值.

惰性计算就是需要结果的时候再执行。

实现方式：

我想到的有2种

嵌套函数调用，类方法的链式调用。


3. 事件委托

>3.1 优点：

减少事件注册，节省内存。比如，
在table上代理所有td的click事件。

在ul上代理所有li的click事件。
简化了dom节点更新时，相应事件的更新。比如
不用在新添加的li上绑定click事件。
当删除某个li时，不用移解绑上面的click事件。

>3.2 缺点：

事件委托基于冒泡，对于不冒泡的事件不支持。

层级过多，冒泡过程中，可能会被某层阻止掉。

理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。
>所以建议就近委托，比如在table上代理td，而不是在document上代理td。
把所有事件都用代理就可能会出现事件误判。比如，在document中代理了所有button的click事件，另外的人在引用改js时，可能不知道，造成单击button触发了两个click事件。

